;;; -*- Mode:Lisp; Syntax:ANSI-Common-Lisp; Coding:utf-8; Package:April -*-
;;;; parallel.lisp

(in-package #:april)

"An implementation of multithreading in April. NOTE: This functionality is still in an alpha state and thus is not implemented by default, therefore this file must be manually compiled."

(defun system-command-exists (command-string &optional prefix)
  (if (not prefix) (setq prefix ""))
  (= 0 (multiple-value-bind (1st 2nd error-code)
	   (uiop:run-program (format nil "~acommand -v ~a" prefix command-string)
			     :ignore-error-status t)
	 (declare (ignore 1st 2nd))
	 error-code)))

(defvar *april-thread-count*
  (with-open-stream (cmd-out (make-string-output-stream))
    (case (uiop:operating-system)
      ((:linux :linux-target)
       (if (system-command-exists "nproc")
	   (progn (uiop:run-program "nproc" :output cmd-out)
		  (read-from-string (get-output-stream-string cmd-out)))
	   1))
      ((:macosx :darwin)
       (if (system-command-exists "sysctl")
	   (progn (uiop:run-program "sysctl -n hw.logicalcpu" :output cmd-out)
		  (read-from-string (get-output-stream-string cmd-out)))
	   1))
      ((:bsd :freebsd :openbsd :netbsd)
       (if (system-command-exists "sysctl")
	   (progn (uiop:run-program "sysctl -n hw.ncpu" :output cmd-out)
		  (read-from-string (get-output-stream-string cmd-out)))
	   1))
      (otherwise 1))))

(defvar *april-parallel-kernel* (lparallel:make-kernel *april-thread-count* :name "april-language-kernel"))

(setf lparallel:*kernel* *april-parallel-kernel*)

(set-system-meta this-idiom :thread-count *april-thread-count*)

(defun rmi-convert (dims index)
  "Convert row-major [index] into a list of the corresponding array coordinates according to [dims] dimensions of array."
  (flet ((rebase (nth-coord number)
	   (let ((operand number) (last-base 1)
		 (base 1) (component 1) (element 0))
	     (loop :for i :from (1- (length dims)) :downto nth-coord
		:do (setq last-base base
			  base (* base (nth i dims))
			  component (if (= 0 base)
					operand (* base (nth-value 1 (floor (/ operand base)))))
			  operand (- operand component)
			  element (/ component last-base)))
	     element)))
    (loop :for d :below (length dims) :collect (rebase d index))))

(defun subs-convert (dims subs)
  (let ((result 0) (factor 1) (dim-index 0))
    (loop :for s :in subs :counting s :into sx
       :do (if (>= s (aref dims dim-index))
	       (error "Invalid index for dimension ~W." sx)
	       (setq result (+ result (* factor s))
		     factor (* factor (aref dims dim-index))
		     dim-index (1+ dim-index))))
    result))

(defun get-indices (dims indices &optional output (dim-index 0) (out-index 0) path)
  (let* ((to-return (null output))
	 (olen (if (not output) (reduce #'* (loop :for i :in indices :for d :across dims
					       :collect (if i (length i) d)))))
	 (output (or output (make-array olen :element-type (list 'integer 0 (reduce #'* dims))))))
    (print (list :in dims indices output))
    (if (first indices)
	(loop :for i :in (if (listp (first indices))
			     (first indices) (list (first indices)))
	   :do (if (not (rest indices))
		   (setf (aref output out-index) (subs-convert dims (reverse (cons i path)))
			 out-index (1+ out-index))
		   (setq out-index (get-indices dims (rest indices)
						output (1+ dim-index) out-index (cons i path)))))
	(loop :for i :below (aref dims dim-index)
	   :do (if (not (rest indices))
		   (setf (aref output out-index) (subs-convert dims (reverse (cons i path)))
			 out-index (1+ out-index))
		   (setq out-index (get-indices dims (rest indices)
						output (1+ dim-index) out-index (cons i path))))))
    (values (if to-return output out-index))))

(defun segment-area (size section-count)
  (let* ((section-count (min section-count size))
	 (division-size (/ size section-count))
	 (start-points (make-array (list section-count)))
	 (section-lengths (make-array (list section-count))))
    (loop :for i :below section-count :do (setf (aref start-points i) (floor (* i division-size))))
    (loop :for i :below section-count :do (setf (aref section-lengths i)
						(- (if (= i (1- section-count))
						       size (aref start-points (1+ i)))
						   (aref start-points i))))
    (values start-points section-lengths section-count)))

(initialize-for-environment
 :across (lambda (original-function)
      	   (lambda (input function &rest args)
      	     (if (and (< 1 *april-thread-count*) (not (getf args :singlethreaded))
      		      (not (getf args :count)) (not (getf args :elements)))
		 (let ((idims (dims input))
		       (isize (size input)))
      		   (multiple-value-bind (start-points lengths count)
      		       (segment-area isize (1- *april-thread-count*))
		     (print (list :st start-points count))
      		     (let ((promises (make-array (list count)
						 :initial-contents (loop :for i :below count :collect (promise)))))
      		       ;; (loop :for p :across promises :do (setf p (promise)))
		       ;; (print (list :pm promises))
      		       (pdotimes (i count)
      			 (apply original-function input function
      				(append (list :count (aref lengths i)
					      :start-at (rmi-convert idims (aref start-points i)))
      					args))
      			 (fulfill (aref promises i) t))
		       ;; (loop :while t :do (print (list :pr promises)) (sleep 1))
		       (loop :for p :across promises :do (force p)))))
      		 (apply original-function input function args)))))

(initialize-for-environment
 :across (lambda (original-function)
      	   (lambda (input function &rest args)
      	     (if (and (< 1 *april-thread-count*) (not (getf args :singlethreaded))
      		      (not (getf args :count)) (not (getf args :elements)))
		 (let ((idims (dims input))
		       (size (array-total-size input))
		       (total 0))
      		   (multiple-value-bind (start-points lengths count)
      		       (segment-area size (1- *april-thread-count*))
		     (print (list :st start-points lengths count size))
      		     (let (;; (promises (make-array (list count)
			   ;; 			 :initial-contents (loop :for i :below count
			   ;; 					      :collect (promise))))
			   (finish-promise (promise)))
      		       (pdotimes (i count)
      			 (apply original-function input function
      				(append (list :count (aref lengths i)
					      :start-at (rmi-convert idims (aref start-points i))
					      ;; :finally (lambda () (fulfill (aref promises i) t))
					      :foreach (lambda () (incf total)))
      					args))
      			 ;; (fulfill (aref promises i) t)
			 )
		       ;; (loop :while t :do (print (list :pr promises)) (sleep 1))
		       (loop :while (< total size)
			  :do (print (list :tt total size))
			    (sleep 1))
		       (fulfill finish-promise)
		       ;; (loop :for p :across promises :do (force p))
		       (force finish-promise)
		       ))
		   (print (list :total total)))
      		 (apply original-function input function args)))))

;; no promises - doesn't work
;; (initialize-for-environment
;;  :across (lambda (original-function)
;;       	   (lambda (input function &rest args)
;;       	     (if (and (< 1 *april-thread-count*) (not (getf args :singlethreaded))
;;       		      (not (getf args :count)) (not (getf args :elements)))
;; 		 (let ((idims (dims input))
;;                     (isize (size input))
;;       		   (multiple-value-bind (start-points lengths count)
;;       		       (segment-area isize (1- *april-thread-count*))
;; 		     (print (list :st start-points count))
;;       		     ;; (loop :for p :across promises :do (setf p (promise)))
;; 		     ;; (print (list :pm promises))
;;       		     (pdotimes (i count)
;;       		       (apply original-function input function
;;       			      (append (list :count (aref lengths i)
;; 					    :start-at (rmi-convert idims (aref start-points i)))
;;       				      args)))))
;;       		 (apply original-function input function args)))))


(defun do-for-scalar-symmetric (omega alpha function)
  (let* (;; (completed 0)
	 (size (array-total-size omega))
	 (output (make-array (dims omega) :initial-element 0))
	 (finish-promise (promise))
	 )
    (multiple-value-bind (start-points lengths count)
	(segment-area size (1- *april-thread-count*))
      (print (list :sp start-points lengths count))
      (pdotimes (i count)
	;; (print (list :iio (aref start-points i) (aref lengths i)))
	(loop :for i :from (aref start-points i) :to (+ (aref start-points i) (aref lengths i) -1)
	   :do (setf (row-major-aref output i) (funcall function (row-major-aref omega i)
							(row-major-aref alpha i))
		    completed (1+ completed))))
      ;; (loop :while (< completed size)
      ;; 	 :do (print (list :tt completed size))
      ;; 	   (sleep 1))
      ;; (fulfill finish-promise)
      ;; (force finish-promise)
      output)))


(defun across2 (array function &key (indices))
  (let* ((dims (dims array)) (size (size array)) (collected)
	 (indices (if indices (get-indices (apply #'vector dims) indices)))
	 (get-index (if (not indices) #'identity (lambda (index) (aref indices index)))))
    (print (list :in indices))
    (multiple-value-bind (start-points lengths count)
	(segment-area (if indices (length indices) size)
		      (1- *april-thread-count*))
      (print (list :sp start-points lengths count))
      (pdotimes (i count)
	;; (print (list :iio (aref start-points i) (aref lengths i)))
	(loop :for i :from (aref start-points i) :to (+ (aref start-points i) (aref lengths i) -1)
	   :do (let ((n (funcall get-index i)))
		 (princ #\@)
		 (setq collected (cons n collected))
		 (funcall function (row-major-aref array n) (rmi-convert dims n)))))
      (print (length collected))
      (print collected))))

;; (defun lp-test (&optional width)
;;   (let* ((thread-count 24) (width (or width 50))
;; 	 (output (make-array (list thread-count width) :initial-element 0)))
;;     (pdotimes (i thread-count)
;;       (loop :for x :below width :do (setf (row-major-aref output (+ x (* i width))) 1)))
;;     :complete))

;; (defun array-row-major-index-vector (array subscripts)
;;   (declare ;; (truly-dynamic-extent subscripts)
;; 	   (dynamic-extent subscripts)
;;            (array array))
;;   (let ((length (length subscripts)))
;;     (cond ((arrayp array)
;;            (let ((rank (rank array)))
;;              (unless (= rank length)
;;                (error "Wrong number of subscripts, ~W, for array of rank ~W."
;;                       length rank))
;;              (do ((axis (1- rank) (1- axis))
;;                   (chunk-size 1)
;;                   (result 0))
;;                  ((minusp axis) result)
;;                (declare (fixnum axis chunk-size result))
;;                (let ((index (aref subscripts axis))
;;                      (dim (array-dimension array axis)))
;; 		 (print (list index dim (> index dim)))
;;                  ;; (unless (and (typep index 'fixnum) (> index dim))
;;                  ;;   ;; (invalid-array-index-error array index dim axis)
;; 		 ;;   (error "Invalid array."))
;;                  (setf result
;;                        (+ result (* chunk-size index))
;;                        chunk-size (* chunk-size dim))))))
;;           ((/= length 1)
;;            (error "Wrong number of subscripts, ~W, for array of rank 1."
;;                   length))
;;           (t
;;            (let ((index (aref subscripts 0))
;;                  (length (length (the (simple-array * (*)) array))))
;;              (unless (and (typep index 'fixnum) (> index length))
;;                ;; (invalid-array-index-error array index length)
;; 	       (error "Invalid array."))
;;              index)))))

;; (defun (setf varef) (new-value array subscripts)
;;   (let ((length (length subscripts))
;; 	(dims (reverse (dims array)))
;; 	(rank (rank array)))
;;     (cond ((/= length rank)
;; 	   (error "Wrong number of subscripts, ~W, for array of rank 1."
;;                   length))
;; 	  ((= 1 rank) (row-major-aref array (aref subscripts 0)))
;; 	  (t (let ((result 0) (factor 1))
;; 	       (loop :for i :from (1- length) :downto 0
;; 		  :do (if (<= (first dims) (aref subscripts i))
;; 			  (error "Invalid index for ~Wth dimension." (1+ (- length i)))
;; 			  (setq result (+ result (* factor (aref subscripts i)))
;; 				factor (* factor (first dims))
;; 				dims (rest dims))))
;; 	       (setf (row-major-aref array (print result)) new-value))))))

#|
(defun divide-volume (dims section-count &optional factor idims divisions)
  (let* ((is-root (not factor))
	 (section-count (min section-count (reduce #'* dims)))
	 (divisions (or divisions (make-array (list section-count) :initial-element nil)))
	 (idims (or idims (sort (mapcar #'list dims (iota (length dims)))
				(lambda (a b) (> (first a) (first b))))))
	 (last-end -1) (this-dim (caar idims)) (factor (* this-dim (or factor 1)))
	 (int-count (loop :for i :below (min section-count this-dim) :collect 0)))
    (flet ((set-interval (interval)
	     (setf (nth interval int-count) (1+ (nth interval int-count)))
	     interval))
      (loop :for c :below section-count
	 :do (setf (aref divisions c)
		   (cons (if (= 0 (mod section-count factor))
			     (set-interval (floor (* c (/ this-dim section-count))))
			     (if (> 1 (floor (* 1 (/ this-dim section-count))))
				 (set-interval (min (1- this-dim)
						    (floor (* c (/ this-dim (1- section-count))))))
				 (let* ((base-start (floor (* c (/ this-dim section-count))))
					(start (max base-start (1+ last-end))))
				   (cons start (setq last-end (min (1- this-dim)
								   (floor (* (+ 1/2 c) (/ this-dim
											  section-count)))))))))
			 (aref divisions c))))
      ;; (print (list :ii divisions idims int-count))
      (if (< factor section-count)
	  (loop :for i :in int-count :summing i :into isum
	     :do (divide-volume (rest dims) i factor (rest idims)
				(make-array (list i) :element-type t :displaced-to divisions
					    :displaced-index-offset (- isum i)))))
      (if is-root (let* ((address-length (length (aref divisions 0)))
			 (ranges (make-array (list section-count)))
			 (max-range (reduce #'max (mapcar #'second (subseq idims 0 address-length)))))
		    (loop :for i :below section-count
		       :do (setf (aref ranges i) (loop :for n :below (1+ max-range) :collect nil))
			 (loop :for x :below address-length :do (setf (nth (- max-range (second (nth x idims)))
									   (aref ranges i))
								      ;; flip the indices to set
								      (nth x (aref divisions i)))))
		    ranges)))))
|#
